Search를  Tree를 이용해서 전개한다.

실제로 트리 탐색이 명시적으로 트리를 만들지 않고

프론티어를 이용하여 탐색을 한다.

또 반복되는 경우를 막기위해 Explode set을 이용합니다.

그래서 반복되는경우 프론티어에 들어가지 못하게 

Tree-Search algorithm

프론티어에서 꺼내서

if Goal 이면 

​	리턴

else:

​	트리를 다시 전개 하여 프론티어에 저장



graph-Search algorithm

queue를 이용하여

FIFO :: 생성된 순서대로 전개되는 방법

LIFO ::  자식을 기준으로 전개 되는 방법

Priority queue  :: 우선순위를 이용하여 꺼내는 







Uninformed search ( blind Search)

​	goal 까지 도착하는데 어떤 노드부터 전개해야하는지 모름

​	그래서 그냥 전개하다가 우연히 goal이 나와 빠르게 될수도 엄청 느릴 수도 있음

​	대부분 FIFO/LIFO queue 를 이용하여 Search하는 경우

​	

Informed Search (heuristic Search)

​	정보를 이용하여 우선순위를 선정후 전개 

​	Priority queue



Uninformed Search

 1. Breadth-first Search  ( graph-Search 기반으로 구현을 함 )

    가장 얕은 unexpanded node를 전개하는 것

    Frontier는 FIFO queue로 구현을 하면 된다.

    

![image-20200324091324858](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20200324091324858.png)

프론티어의 사이즈는  $$O(b^d)$$ depth 가 커질수록 엄청 커진다.

메모리 기반으로 간다하면 explored set이 필요하다.

Size of explored set  :: $$O(b^d)-1$$ 항상 leaf는 위에 부모 노드보다 항상 1개 작다.

Tree-Search-based로 짜더라도 브랜치가 많아져서 시간이 많이 걸릴 뿐 만들 수 있긴 하다.

하지만 비효율적이다.



  여기서 G가 Goal일 경우 부모 노드만 Goal의 여부를 검사하기 떄문에 D,E,F가 전개 후에 Goal이란 것을 알게 되어 비효율적이다.  

![image-20200324092354034](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20200324092354034.png)

2. Uniform-cost Search 

   Priority Search를 사용  == > 지나온 노드 중 가장 작은 코스트를 찾는 것이기 떄문에 inform Search가 아니다. 

   Breadth-first에서 step-cost 개념을 도입

   redundant Path를 허용하는 방법이 필요하다.

   Tree-Search 기반으로 하면 효율이 떨어집니다.(Graph-Search 기반으로 한다)

   least-cost를 찾는 전제조건은 Negative cost가 없어야한다.

   ![image-20200324095451040](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20200324095451040.png)

   Goal에 도달한다고 해도 최단 cost인지 모르기 때문에 다른 것도 전개해봐야 안다.

   :: goal test를 전개하기 직전에 해야한다. 

   

   ![image-20200324095750151](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20200324095750151.png)

   

Depth-first Search 

​	Frontier는 stack, Frontier의 크기가 크지않다 

​	== 자식들만 넣으니까 

![image-20200326090247695](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20200326090247695.png)

트리 기반 구현

​	:: 무한루프를 피해야한다.

​	Redundant paths는 못피한다.

​	:: 메모리셋이 그렇게 많이 필요하지 않다.

​	평가 ::

​				메모리 요구량 : $$O(bm)$$

​				(b : branching factor, m : maximum depth)

​				시간복잡도 : $$O(b^m)$$

​				 탐색 공간이 무한하다면 솔루션을 찾지 못하는 경우도 생긴다.

​				솔루션을 찾는다 하더라도 Optimal 한 솔루션을 찾기 힘들다.

​				finite spaces라면 결국은 답을 찾아 낼 것이다.

​				redundant path 때문에 무조건 Optimal 한 솔루션이라고 보장하긴 힘들다.



​		

그래프 기반 구현

​	:: explored set이 exponential size를 가진다.

​	:: 메모리 요구량이 많기 떄문에 사용하기 힘들다.

​	





Depth-limited Search :: Search space가 무한대일경우 문제점이 발생하여 나온 개념

​	:: Tree-Search 기반 구현

​	:: Depth limite 을 사용자가 잡아서 트리를 이용함.

​	:: TIme : $$O(b^l)$$

​	:: Space :: $$O(bl)$$

​	::  d<= l  이라면 솔루션을 찾을 수 없을 수도 있다.

​	![image-20200326093136827](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20200326093136827.png)

depth-limit Search를 Limit를 늘리면서 솔루션을 찾아내는 알고리즘

유사한 알고리즘

​	Lterative-lengthening-search

​						path-cost를 늘려가면서 찾아냄

Depth가 가장 작은 솔루션을 찾아준다.

프론티어의 메모리는 별로필요하지않고

Breadth-first + depth-first  장점들을 합쳤다.

Time :: $$O(b^d)$$

Space :: $$O(bd) $$

​	



Bidirectional Search

​	start  < = > Goal

​	양쪽에서 동시에 출발해서 서로 만나는 것을 목표로 한다.

​	Search space가 획기적으로 작아진다.

​	 $$O(b^{d/2})$$

​	양쪽에서 서로 다 BFS 할 경우

​	Iterative-Deeping-Search를 할경우로 

​	구현하면 된다.

​	 